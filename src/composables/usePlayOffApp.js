import { ref, computed, onMounted } from 'vue'

// Composable principal da aplica√ß√£o PlayOff
// Este composable centraliza toda a l√≥gica de estado e opera√ß√µes relacionadas
// ao sistema de vota√ß√£o e gerenciamento de m√∫sicas. Desenvolvido com Vue 3
// Composition API para m√°xima reatividade e performance
export function usePlayOffApp() {
  // ============= ESTADO REATIVO =============
  // Gerencio todo o estado da aplica√ß√£o de forma reativa usando ref()
  // Isso garante que a interface seja atualizada automaticamente quando os dados mudam
  
  const songs = ref([])              // Lista principal de m√∫sicas
  const isOnline = ref(true)         // Status de conex√£o com o backend
  const notifications = ref([])      // Sistema de notifica√ß√µes em tempo real
  
  // ============= CONFIGURA√á√ÉO DA API =============
  // URL base para comunica√ß√£o com o backend
  // Em produ√ß√£o, isso seria configurado via vari√°veis de ambiente
  const apiBaseUrl = '/api'
  
  // ============= COMPUTED PROPERTIES =============
  // Computed que sempre retorna as m√∫sicas ordenadas por votos
  // √â reativo, ent√£o qualquer mudan√ßa nos votos recalcula automaticamente a ordena√ß√£o
  const sortedSongs = computed(() => {
    return [...songs.value].sort((a, b) => b.votes - a.votes)
  })
  
  // ============= FUN√á√ïES DE COMUNICA√á√ÉO COM BACKEND =============
  
  // Fun√ß√£o principal para carregar m√∫sicas do servidor
  // Implemento tratamento de erro robusto para lidar com backend offline
  // Esta fun√ß√£o √© chamada na inicializa√ß√£o e periodicamente para sincroniza√ß√£o
  const loadSongsFromBackend = async () => {
    try {
      console.log('üì° Tentando carregar m√∫sicas do backend...')
      const response = await fetch(`${apiBaseUrl}/songs`)
      
      if (response.ok) {
        const data = await response.json()
        songs.value = data.songs || []
        console.log(`‚úÖ ${songs.value.length} m√∫sicas carregadas do backend com sucesso`)
        return true
      } else {
        throw new Error(`Resposta HTTP ${response.status}`)
      }
    } catch (error) {
      console.log('üîå Backend offline ou inacess√≠vel, falhando graciosamente:', error.message)
      throw error
    }
  }
  
  // Fun√ß√£o para carregar dados de demonstra√ß√£o quando o backend n√£o est√° dispon√≠vel
  // Isso garante que a aplica√ß√£o continue funcionando mesmo sem conectividade
  // Os dados demo s√£o representativos e permitem testar todas as funcionalidades
  const loadDemoData = () => {
    console.log('üìÄ Carregando dados demo para funcionamento offline...')
    
    songs.value = [
      {
        id: 'audioslave-cochise',
        title: 'Cochise',
        artist: 'Audioslave',
        audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748878548/Audioslave_-_Cochise_HD_YymwGlbqzIc_lz8zjk.mp3',
        albumCover: 'https://upload.wikimedia.org/wikipedia/en/b/b8/Audioslave_-_Audioslave.jpg',
        album: 'Audioslave',
        votes: 5
      },
      {
        id: 'deftones-change',
        title: 'Change (In the House of Flies)',
        artist: 'Deftones',
        audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879300/Deftones_-_Change_In_The_House_Of_Flies_oSDNIINcK08_ejs6hn.mp3',
        albumCover: 'https://upload.wikimedia.org/wikipedia/en/6/68/Deftones_-_White_Pony.jpg',
        album: 'White Pony',
        votes: 8
      },
      {
        id: 'qotsa-bronze',
        title: 'The Bronze',
        artist: 'Queens of the Stone Age',
        audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879302/Queens_Of_The_Stone_Age_The_Bronze_P3kM58n2ceE_x9m9kx.mp3',
        albumCover: 'https://upload.wikimedia.org/wikipedia/en/5/5d/Queens_of_the_Stone_Age_%28Queens_of_the_Stone_Age_album_-_cover_art%29.jpg',
        album: 'Queens of the Stone Age',
        votes: 3
      },
      {
        id: 'deftones-my-own-summer',
        title: 'My Own Summer (Shove It)',
        artist: 'Deftones',
        audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879303/Deftones_-_My_Own_Summer_vLjOwAPzt4o_xdemns.mp3',
        albumCover: 'https://upload.wikimedia.org/wikipedia/en/a/a3/Deftones_-_Around_the_Fur.jpg',
        album: 'Around the Fur',
        votes: 6
      }
    ]
    
    console.log(`üìÄ ${songs.value.length} m√∫sicas demo carregadas para desenvolvimento/teste`)
  }
  
  // ============= SISTEMA DE VOTA√á√ÉO =============
  
  // Fun√ß√£o para enviar voto ao backend
  // Implemento verifica√ß√£o de conectividade para evitar erros quando offline
  // Esta fun√ß√£o √© chamada ap√≥s atualizar o estado local para responsividade
  const submitVoteToBackend = async (songId, votes) => {
    if (!isOnline.value) {
      console.log('‚ö†Ô∏è Offline: Voto salvo apenas localmente')
      return false
    }
    
    try {
      console.log(`üì§ Enviando voto para backend: m√∫sica ${songId}, total ${votes} votos`)
      const response = await fetch(`${apiBaseUrl}/vote`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          songId: songId,
          votes: votes
        }),
      })
      
      if (response.ok) {
        console.log('‚úÖ Voto sincronizado com backend com sucesso')
        return true
      } else {
        throw new Error(`Erro HTTP ${response.status}`)
      }
    } catch (error) {
      console.error('‚ùå Falha ao sincronizar voto com backend:', error)
      // Marco como offline para futuras opera√ß√µes
      isOnline.value = false
      return false
    }
  }
  
  // Fun√ß√£o principal para votar em uma m√∫sica
  // Implemento otimistic UI updates - atualizo a interface imediatamente
  // e depois sincronizo com o servidor. Isso proporciona experi√™ncia mais fluida
  const voteForSong = async (songId) => {
    try {
      console.log(`üó≥Ô∏è Processando voto para m√∫sica ID: ${songId}`)
      
      // Encontro a m√∫sica na lista local
      const song = songs.value.find(s => s.id === songId)
      if (!song) {
        console.error('‚ùå M√∫sica n√£o encontrada na lista local:', songId)
        showNotification('M√∫sica n√£o encontrada', 'error')
        return null
      }
      
      // Atualizo votos localmente primeiro (otimistic update)
      const oldVotes = song.votes || 0
      song.votes = oldVotes + 1
      console.log(`üìä Votos atualizados localmente: ${oldVotes} ‚Üí ${song.votes}`)
      
      // Tento sincronizar com backend em background
      await submitVoteToBackend(songId, song.votes)
      
      // Feedback positivo para o usu√°rio
      showNotification(`üó≥Ô∏è Voto registrado para "${song.title}"!`, 'success')
      
      return song
    } catch (error) {
      console.error('‚ùå Erro cr√≠tico na vota√ß√£o:', error)
      showNotification('Erro inesperado ao votar', 'error')
      return null
    }
  }
  
  // ============= SISTEMA DE SUPER VOTO =============
  
  // Fun√ß√£o avan√ßada de super voto que garante lideran√ßa imediata
  // Esta √© uma funcionalidade premium que calcula dinamicamente quantos votos
  // s√£o necess√°rios para que a m√∫sica escolhida assuma a primeira posi√ß√£o
  const superVote = async (songId, currentPlayingSong = null) => {
    try {
      console.log(`‚ö° Iniciando super voto para m√∫sica ID: ${songId}`)
      
      // Encontro a m√∫sica alvo
      const song = songs.value.find(s => s.id === songId)
      if (!song) {
        console.error('‚ùå M√∫sica para super voto n√£o encontrada:', songId)
        showNotification('M√∫sica n√£o encontrada', 'error')
        return null
      }
      
      // C√°lculo inteligente dos votos necess√°rios para lideran√ßa
      let highestVotes = 0
      
      // Se h√° uma m√∫sica tocando atualmente, uso seus votos como refer√™ncia
      if (currentPlayingSong && currentPlayingSong.id !== songId) {
        highestVotes = currentPlayingSong.votes || 0
        console.log(`üìä Usando m√∫sica atual como refer√™ncia: ${highestVotes} votos`)
      } else {
        // Caso contr√°rio, encontro a m√∫sica com mais votos (excluindo a alvo)
        const otherSongs = songs.value.filter(s => s.id !== songId)
        if (otherSongs.length > 0) {
          highestVotes = Math.max(...otherSongs.map(s => s.votes || 0))
          console.log(`üìä Maior n√∫mero de votos encontrado: ${highestVotes}`)
        }
      }
      
      // Calculo votos necess√°rios (pelo menos 1 voto a mais que o l√≠der)
      const currentVotes = song.votes || 0
      const votesNeeded = Math.max(1, (highestVotes + 1) - currentVotes)
      
      console.log(`‚ö° An√°lise do super voto:`)
      console.log(`   - M√∫sica "${song.title}" tem atualmente: ${currentVotes} votos`)
      console.log(`   - L√≠der atual tem: ${highestVotes} votos`)
      console.log(`   - Votos necess√°rios para lideran√ßa: ${votesNeeded}`)
      
      // Atualizo votos localmente (otimistic update)
      song.votes = currentVotes + votesNeeded
      console.log(`üìä Super voto conclu√≠do: ${currentVotes} ‚Üí ${song.votes} votos`)
      
      // Sincronizo com backend
      await submitSuperVoteToBackend(songId, song.votes, votesNeeded)
      
      // Feedback especial para super voto
      showNotification(
        `‚ö° Super Voto executado! "${song.title}" agora lidera com ${song.votes} votos!`, 
        'success'
      )
      
      return song
    } catch (error) {
      console.error('‚ùå Erro cr√≠tico no super voto:', error)
      showNotification('Erro inesperado no super voto', 'error')
      return null
    }
  }
  
  // Fun√ß√£o espec√≠fica para sincronizar super votos com o backend
  // O super voto requer endpoint diferente pois envia informa√ß√µes adicionais
  // sobre quantos votos foram adicionados de uma vez
  const submitSuperVoteToBackend = async (songId, totalVotes, votesAdded) => {
    if (!isOnline.value) {
      console.log('‚ö†Ô∏è Offline: Super voto salvo apenas localmente')
      return false
    }
    
    try {
      console.log(`üì§ Sincronizando super voto: ${votesAdded} votos adicionados (total: ${totalVotes})`)
      const response = await fetch(`${apiBaseUrl}/super-vote`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          songId: songId,
          totalVotes: totalVotes,
          votesAdded: votesAdded
        }),
      })
      
      if (response.ok) {
        console.log('‚úÖ Super voto sincronizado com backend com sucesso')
        return true
      } else {
        throw new Error(`Erro HTTP ${response.status}`)
      }
    } catch (error) {
      console.error('‚ùå Falha ao sincronizar super voto:', error)
      isOnline.value = false
      return false
    }
  }
  
  // ============= SISTEMA DE NOTIFICA√á√ïES =============
  
  // Sistema de notifica√ß√µes em tempo real com auto-dismiss
  // Implemento diferentes tipos de notifica√ß√£o (success, error, warning, info)
  // com remo√ß√£o autom√°tica para n√£o sobrecarregar a interface
  const showNotification = (message, type = 'info') => {
    const notification = {
      id: Date.now() + Math.random(), // ID √∫nico para cada notifica√ß√£o
      message,
      type,
      timestamp: new Date().toISOString()
    }
    
    // Adiciono √† lista de notifica√ß√µes ativas
    notifications.value.push(notification)
    
    // Auto-remo√ß√£o ap√≥s 3 segundos para manter interface limpa
    setTimeout(() => {
      const index = notifications.value.findIndex(n => n.id === notification.id)
      if (index > -1) {
        notifications.value.splice(index, 1)
        console.log(`üóëÔ∏è Notifica√ß√£o removida automaticamente: ${message}`)
      }
    }, 3000)
    
    // Log para debugging
    console.log(`üì¢ NOTIFICA√á√ÉO [${type.toUpperCase()}]: ${message}`)
  }

  // ============= INICIALIZA√á√ÉO E SINCRONIZA√á√ÉO =============
  
  // Fun√ß√£o principal de inicializa√ß√£o da aplica√ß√£o
  // Tenta conectar com backend primeiro, fallback para dados demo se falhar
  // Esta estrat√©gia garante que a aplica√ß√£o sempre funcione
  const initializeData = async () => {
    console.log('üöÄ Inicializando sistema PlayOff...')
    
    try {
      // Tentativa principal: carregar do backend
      await loadSongsFromBackend()
      isOnline.value = true
      console.log('‚úÖ Inicializa√ß√£o online conclu√≠da com sucesso')
    } catch (error) {
      console.log('üîå Backend n√£o dispon√≠vel durante inicializa√ß√£o, modo offline ativado')
      loadDemoData()
      isOnline.value = false
      
      // Mostro notifica√ß√£o informativa sobre modo offline
      showNotification('Modo offline: usando dados de demonstra√ß√£o', 'warning')
    }
  }
  
  // Sistema de atualiza√ß√£o peri√≥dica com frequ√™ncia reduzida
  // Implemento polling inteligente para manter dados sincronizados
  // Frequ√™ncia reduzida (15s) para economizar recursos e reduzir carga no servidor
  const startUpdateLoops = () => {
    console.log('üîÑ Iniciando loops de atualiza√ß√£o autom√°tica (intervalo: 15s)')
    
    // Atualiza√ß√£o peri√≥dica das m√∫sicas
    setInterval(async () => {
      if (isOnline.value) {
        try {
          await refreshSongs()
        } catch (error) {
          console.log('‚ö†Ô∏è Erro durante atualiza√ß√£o autom√°tica:', error.message)
          // N√£o marco como offline aqui para evitar false negatives
        }
      }
    }, 15000) // 15 segundos - reduzido de 5s para melhor performance
  }
  
  // ============= DEBOUNCING E OTIMIZA√á√ÉO =============
  
  // Implemento debouncing para atualiza√ß√µes de m√∫sicas
  // Isso previne m√∫ltiplas chamadas desnecess√°rias em r√°pida sucess√£o
  // Especialmente √∫til quando m√∫ltiplos usu√°rios votam simultaneamente
  let songsUpdateTimeout = null
  
  const debouncedUpdateSongs = () => {
    // Cancelo timeout anterior se existir
    if (songsUpdateTimeout) {
      clearTimeout(songsUpdateTimeout)
    }
    
    // Agendo nova atualiza√ß√£o com delay
    songsUpdateTimeout = setTimeout(async () => {
      try {
        console.log('üîÑ Executando atualiza√ß√£o debounced...')
        await refreshSongs()
      } catch (error) {
        console.log('‚ö†Ô∏è Erro na atualiza√ß√£o debounced:', error.message)
      }
    }, 1000) // 1 segundo de delay
  }
  
  // Fun√ß√£o para atualizar m√∫sicas do backend de forma inteligente
  // Implemento compara√ß√£o de conte√∫do para evitar re-renders desnecess√°rios
  // S√≥ atualizo o estado se os dados realmente mudaram
  const refreshSongs = async () => {
    if (!isOnline.value) {
      console.log('‚ö†Ô∏è Tentativa de refresh offline - ignorando')
      return
    }
    
    try {
      console.log('üîÑ Atualizando lista de m√∫sicas...')
      const response = await fetch(`${apiBaseUrl}/songs`)
      
      if (response.ok) {
        const data = await response.json()
        const newSongs = data.songs || []
        
        // Compara√ß√£o inteligente: s√≥ atualizo se dados mudaram
        const songsChanged = JSON.stringify(songs.value) !== JSON.stringify(newSongs)
        
        if (songsChanged) {
          const previousCount = songs.value.length
          songs.value = newSongs
          
          console.log(`üîÑ Lista atualizada: ${previousCount} ‚Üí ${newSongs.length} m√∫sicas`)
          
          // Log das mudan√ßas para debugging
          if (newSongs.length > previousCount) {
            console.log(`‚ûï ${newSongs.length - previousCount} nova(s) m√∫sica(s) adicionada(s)`)
          } else if (newSongs.length < previousCount) {
            console.log(`‚ûñ ${previousCount - newSongs.length} m√∫sica(s) removida(s)`)
          } else {
            console.log('üìä Votos atualizados (mesmo n√∫mero de m√∫sicas)')
          }
        } else {
          // Dados id√™nticos - n√£o preciso atualizar
          console.log('‚úì Lista j√° est√° atualizada (sem mudan√ßas)')
        }
      } else {
        throw new Error(`Resposta HTTP ${response.status}`)
      }
    } catch (error) {
      console.error('‚ùå Erro ao atualizar m√∫sicas:', error)
      // Marco como offline para pausar futuras tentativas autom√°ticas
      isOnline.value = false
      showNotification('Conex√£o perdida - modo offline ativado', 'warning')
    }
  }
  
  // ============= INTERFACE P√öBLICA DO COMPOSABLE =============
  // Retorno apenas o que √© necess√°rio para os componentes
  // Isso mant√©m a API limpa e previne uso indevido de fun√ß√µes internas
  return {
    // Estado reativo
    songs,                    // Lista de m√∫sicas
    sortedSongs,             // M√∫sicas ordenadas por votos  
    notifications,           // Sistema de notifica√ß√µes
    isOnline,               // Status de conectividade
    
    // A√ß√µes principais
    voteForSong,            // Votar em m√∫sica
    superVote,              // Super voto (lideran√ßa garantida)
    showNotification,       // Mostrar notifica√ß√£o
    
    // Inicializa√ß√£o e sincroniza√ß√£o
    initializeData,         // Inicializar aplica√ß√£o
    startUpdateLoops,       // Iniciar atualiza√ß√µes autom√°ticas
    refreshSongs            // Atualizar m√∫sicas manualmente
  }
} 