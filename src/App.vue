<template>
  <div class="app">
    <!-- Elementos de Fundo -->
    <div class="background-overlay"></div>
    <div class="dynamic-background" :class="{ active: currentTrack }"></div>
    
    <!-- Sistema de Notifica√ß√µes -->
    <NotificationContainer :notifications="notifications" />
    
    <div class="container">
      <!-- Conte√∫do Principal -->
      <div class="main-content">
        <!-- Se√ß√£o Hero com Player de M√∫sica -->
        <HeroSection 
          :current-track="currentTrack"
          :is-playing="isPlaying"
          :position="position"
          :duration="duration"
          :format-time="formatTime"
          @toggle-playback="togglePlayback"
          @previous-track="handlePreviousTrack"
          @next-track="handleNextTrack"
        />

        <!-- Carrossel de M√∫sicas para Vota√ß√£o -->
        <MusicCarousel 
          :songs="sortedSongs"
          :current-track="currentTrack"
          :is-playing="isPlaying"
          @vote-for-song="handleVoteAndPlay"
          @super-vote="handleSuperVote"
          @play-song="handlePlaySong"
        />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch, onUnmounted } from 'vue'
import { useCloudinaryAudio } from './composables/useCloudinaryAudio'
import { usePlayOffApp } from './composables/usePlayOffApp'
import HeroSection from './components/HeroSection.vue'
import MusicCarousel from './components/MusicCarousel.vue'
import NotificationContainer from './components/NotificationContainer.vue'

// ============= COMPOSABLES E ESTADO =============
// Utilizo composables para separar responsabilidades e manter c√≥digo organizado
// useCloudinaryAudio: gerencia reprodu√ß√£o de √°udio e integra√ß√£o com APIs de m√∫sica
// usePlayOffApp: gerencia estado da aplica√ß√£o, vota√ß√£o e sincroniza√ß√£o com backend

const {
  currentTrack,        // M√∫sica sendo reproduzida atualmente
  isPlaying,          // Status de reprodu√ß√£o (true/false)
  position,           // Posi√ß√£o atual da m√∫sica em ms
  duration,           // Dura√ß√£o total da m√∫sica em ms
  initializePlayer,   // Inicializar sistema de √°udio
  playSong,          // Reproduzir uma m√∫sica espec√≠fica
  togglePlayback,    // Alternar play/pause
  previousTrack,     // Ir para m√∫sica anterior
  nextTrack,         // Ir para pr√≥xima m√∫sica
  formatTime,        // Formatar tempo (ms para mm:ss)
  updateSongsList    // Atualizar lista para navega√ß√£o
} = useCloudinaryAudio()

const {
  songs,              // Lista de m√∫sicas (estado bruto)
  sortedSongs,        // M√∫sicas ordenadas por votos (computed)
  notifications,      // Lista de notifica√ß√µes ativas
  voteForSong,       // Fun√ß√£o para votar em m√∫sica
  superVote,         // Fun√ß√£o para super voto
  showNotification,  // Mostrar notifica√ß√£o ao usu√°rio
  initializeData,    // Carregar dados iniciais
  startUpdateLoops,  // Iniciar sincroniza√ß√£o autom√°tica
  refreshSongs       // Atualizar m√∫sicas manualmente
} = usePlayOffApp()

// ============= L√ìGICA DE AUTO-REPRODU√á√ÉO =============
// Sistema inteligente que automaticamente reproduz a m√∫sica mais votada
// quando h√° mudan√ßas na lideran√ßa. Isso torna a experi√™ncia mais din√¢mica
// e recompensa imediatamente a m√∫sica que est√° ganhando mais votos

const checkAndPlayHighestVoted = async () => {
  // Verifico se h√° m√∫sicas dispon√≠veis
  if (sortedSongs.value.length === 0) {
    console.log('üì≠ Nenhuma m√∫sica dispon√≠vel para auto-reprodu√ß√£o')
    return
  }
  
  // Obtenho a m√∫sica mais votada (primeira na lista ordenada)
  const highestVoted = sortedSongs.value[0]
  
  // S√≥ reproduzo automaticamente se:
  // 1. A m√∫sica tem pelo menos 1 voto (evita tocar m√∫sicas sem engajamento)
  // 2. √â diferente da m√∫sica atual (evita reiniciar a mesma m√∫sica)
  const shouldAutoPlay = highestVoted.votes > 0 && 
                         (!currentTrack.value || currentTrack.value.id !== highestVoted.id)
  
  if (shouldAutoPlay) {
    console.log(`üèÜ Auto-reproduzindo m√∫sica l√≠der: "${highestVoted.title}" (${highestVoted.votes} votos)`)
    await handlePlaySong(highestVoted)
  } else {
    console.log(`‚è∏Ô∏è Auto-reprodu√ß√£o n√£o necess√°ria - m√∫sica j√° √© a atual ou sem votos`)
  }
}

// ============= HANDLERS DE EVENTOS =============
// Fun√ß√µes que lidam com intera√ß√µes do usu√°rio e coordenam a√ß√µes entre composables

// Handler para voto simples + verifica√ß√£o de auto-reprodu√ß√£o
// Esta fun√ß√£o demonstra como coordeno diferentes sistemas: vota√ß√£o e reprodu√ß√£o
const handleVoteAndPlay = async (songId) => {
  console.log(`üó≥Ô∏è App.vue: Processando voto para m√∫sica ID: ${songId}`)
  
  // Executo o voto atrav√©s do composable
  const votedSong = await voteForSong(songId)
  
  if (votedSong) {
    console.log(`‚úÖ Voto registrado para "${votedSong.title}" - nova contagem: ${votedSong.votes}`)
    
    // Aguardo um momento para que o voto seja processado e a lista reordenada
    // Ent√£o verifico se esta m√∫sica agora deve ser auto-reproduzida
    setTimeout(() => {
      console.log('üîÑ Verificando se nova m√∫sica deve ser auto-reproduzida...')
      checkAndPlayHighestVoted()
    }, 500) // Delay de 500ms para garantir processamento do voto
  } else {
    console.log('‚ùå Falha no voto - n√£o verificando auto-reprodu√ß√£o')
  }
}

// Handler para super voto (voto + reprodu√ß√£o imediata garantida)
// O super voto √© uma funcionalidade premium que garante reprodu√ß√£o imediata
const handleSuperVote = async (song) => {
  try {
    console.log(`‚ö° App.vue: Processando super voto para "${song.title}"`)
    
    // Executo o super voto passando a m√∫sica atual como refer√™ncia
    // Isso permite calcular quantos votos s√£o necess√°rios para assumir lideran√ßa
    const superVotedSong = await superVote(song.id, currentTrack.value)
    
    if (superVotedSong) {
      console.log(`‚ö° Super voto executado: "${superVotedSong.title}" agora tem ${superVotedSong.votes} votos`)
      
      // Reproduzo imediatamente (caracter√≠stica do super voto)
      await handlePlaySong(song)
      
      // Feedback espec√≠fico para super voto
      showNotification(`‚ö° Super Voto! Tocando imediatamente: ${song.title}`, 'success')
    }
  } catch (error) {
    console.error('‚ùå App.vue: Erro cr√≠tico no super voto:', error)
    showNotification('Erro no super voto - tente novamente', 'error')
  }
}

// Handler principal para reprodu√ß√£o de m√∫sicas
// Centraliza toda a l√≥gica de reprodu√ß√£o e logging detalhado para debugging
const handlePlaySong = async (song) => {
  try {
    console.log(`üéµ App.vue: Iniciando reprodu√ß√£o de "${song.title}" por ${song.artist}`)
    console.log(`üé® App.vue: Capa do √°lbum: ${song.albumCover}`)
    console.log(`üìä App.vue: Votos atuais: ${song.votes}`)
    
    // Chamo a fun√ß√£o de reprodu√ß√£o do composable de √°udio
    await playSong(song)
    
    console.log(`‚úÖ App.vue: Reprodu√ß√£o iniciada com sucesso`)
    console.log(`üìä App.vue: Estado atual do player:`, {
      currentTrack: currentTrack.value?.title,
      isPlaying: isPlaying.value,
      albumCover: currentTrack.value?.albumCover
    })
    
    // Feedback para o usu√°rio
    showNotification(`üéµ Reproduzindo: ${song.title}`, 'success')
  } catch (error) {
    console.error('‚ùå App.vue: Erro ao reproduzir m√∫sica:', error)
    showNotification('Erro ao reproduzir m√∫sica - verifique conex√£o', 'error')
  }
}

// ============= GERENCIAMENTO DE CORES DIN√ÇMICAS =============
// Sistema que extrai cores das capas dos √°lbuns e aplica temas din√¢micos
// Isso cria uma experi√™ncia visual mais imersiva e personalizada

const handleAlbumColorExtracted = (event) => {
  try {
    console.log('üé® App.vue: Evento de extra√ß√£o de cor recebido:', event.detail)
    
    // Extraio informa√ß√µes do evento personalizado
    const { 
      dominant,        // Cor dominante [r, g, b]
      palette,         // Paleta de cores [[r,g,b], ...]
      theme,          // Tema determinado (warm, cool, vibrant, neutral)
      brightness,     // Brilho da imagem (0-1)
      albumCover     // URL da capa analisada
    } = event.detail
    
    // Aplico o tema extra√≠do ao documento
    // Isso muda as cores de fundo, gradientes e elementos da interface
    if (theme) {
      const body = document.body
      const themes = ['theme-warm', 'theme-cool', 'theme-vibrant', 'theme-neutral', 'theme-black']
      
      // Removo temas anteriores
      themes.forEach(t => body.classList.remove(t))
      
      // Aplico novo tema
      body.classList.add(`theme-${theme}`)
      
      console.log(`üé® Tema aplicado: ${theme}`)
      console.log(`üåà Cor dominante: rgb(${dominant.join(', ')})`)
      console.log(`üí° Brilho detectado: ${brightness.toFixed(2)}`)
    }
  } catch (error) {
    console.error('‚ùå Erro ao processar cores do √°lbum:', error)
    // Em caso de erro, mantenho tema padr√£o
    document.body.classList.add('theme-black')
  }
}

// ============= WATCHERS REATIVOS =============
// Observadores que reagem a mudan√ßas de estado e mant√™m sincroniza√ß√£o

// Observo mudan√ßas na lista de m√∫sicas ordenadas para atualizar navega√ß√£o do player
// Isso garante que as fun√ß√µes "pr√≥xima/anterior" funcionem com a lista atual
watch(sortedSongs, (newSongs) => {
  if (newSongs && newSongs.length > 0) {
    console.log(`üîÑ App.vue: Atualizando lista de navega√ß√£o com ${newSongs.length} m√∫sicas`)
    updateSongsList(newSongs)
  } else {
    console.log('üì≠ Lista de m√∫sicas vazia - navega√ß√£o desabilitada')
  }
}, { deep: true, immediate: true }) // deep: true para mudan√ßas internas, immediate: true para execu√ß√£o inicial

// ============= HANDLERS DE NAVEGA√á√ÉO =============
// Fun√ß√µes que permitem navegar entre m√∫sicas com tratamento de erro

const handlePreviousTrack = async () => {
  try {
    console.log('‚èÆÔ∏è App.vue: Navegando para m√∫sica anterior...')
    await previousTrack(sortedSongs.value)
    console.log('‚úÖ Navega√ß√£o para anterior conclu√≠da')
  } catch (error) {
    console.error('‚ùå Erro ao navegar para m√∫sica anterior:', error)
    showNotification('Erro ao navegar para m√∫sica anterior', 'error')
  }
}

const handleNextTrack = async () => {
  try {
    console.log('‚è≠Ô∏è App.vue: Navegando para pr√≥xima m√∫sica...')
    await nextTrack(sortedSongs.value)
    console.log('‚úÖ Navega√ß√£o para pr√≥xima conclu√≠da')
  } catch (error) {
    console.error('‚ùå Erro ao navegar para pr√≥xima m√∫sica:', error)
    showNotification('Erro ao navegar para pr√≥xima m√∫sica', 'error')
  }
}

// ============= CICLO DE VIDA DO COMPONENTE =============

// Inicializa√ß√£o quando o componente √© montado
onMounted(async () => {
  console.log('üöÄ App.vue: Iniciando aplica√ß√£o PlayOff Vue...')
  
  try {
    // Sequ√™ncia de inicializa√ß√£o ordenada
    console.log('üîß 1/4: Inicializando player de √°udio...')
    await initializePlayer()
    
    console.log('üì¶ 2/4: Carregando dados da aplica√ß√£o...')
    await initializeData()
    
    console.log('üîÑ 3/4: Iniciando loops de atualiza√ß√£o...')
    startUpdateLoops()
    
    console.log('üé® 4/4: Configurando listeners de eventos...')
    // Escuto eventos de extra√ß√£o de cor das capas de √°lbum
    window.addEventListener('albumColorExtracted', handleAlbumColorExtracted)
    
    console.log('‚úÖ PlayOff Vue App inicializado com sucesso!')
    showNotification('üéµ PlayOff carregado! Comece a votar!', 'success')
    
    // Verifico se devo reproduzir alguma m√∫sica automaticamente
    // Aguardo 2 segundos para garantir que tudo esteja carregado
    setTimeout(() => {
      console.log('üéØ Verificando auto-reprodu√ß√£o inicial...')
      checkAndPlayHighestVoted()
    }, 2000)
    
  } catch (error) {
    console.error('‚ùå Erro cr√≠tico durante inicializa√ß√£o:', error)
    showNotification('Erro ao inicializar - algumas funcionalidades podem n√£o funcionar', 'error')
  }
})

// Limpeza quando o componente √© desmontado
onUnmounted(() => {
  console.log('üßπ App.vue: Limpando recursos...')
  
  // Removo event listeners para evitar memory leaks
  window.removeEventListener('albumColorExtracted', handleAlbumColorExtracted)
  
  console.log('‚úÖ Limpeza conclu√≠da')
})
</script>

<style scoped>
/* Estilos do componente principal */
.app {
  width: 100%;
  min-height: 100vh;
  position: relative;
}

.container {
  width: 100%;
  min-height: 100vh;
  position: relative;
  z-index: 2;
}

.main-content {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}
</style> 