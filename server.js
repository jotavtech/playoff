const express = require('express');
const cors = require('cors');
const path = require('path');

// Importa√ß√£o do fetch para vers√µes do Node.js que n√£o possuem suporte nativo
// Isso garante compatibilidade com APIs externas independente da vers√£o do Node
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));

// ============= IMPLEMENTA√á√ÉO DO PADR√ÉO OBSERVER =============
// O padr√£o Observer √© uma solu√ß√£o elegante que desenvolvi para este projeto
// Ele permite que diferentes componentes do sistema sejam notificados automaticamente
// quando algo importante acontece, como um novo voto ou mudan√ßa na m√∫sica mais votada
// 
// Principais vantagens desta arquitetura:
// 1. Desacoplamento: Os componentes n√£o precisam conhecer uns aos outros diretamente
// 2. Escalabilidade: Posso adicionar novos observadores sem modificar c√≥digo existente  
// 3. Manutenibilidade: Cada classe tem uma responsabilidade espec√≠fica e bem definida
// 4. Reatividade: O sistema reage automaticamente a mudan√ßas de estado

// Interface Observer - Define o contrato que todos os observadores devem seguir
// Esta √© a base do padr√£o Observer, garantindo que todos os observadores
// implementem o m√©todo update() que ser√° chamado quando houver notifica√ß√µes
class Observer {
  update(data) {
    throw new Error('M√©todo update do Observer deve ser implementado');
  }
}

// Classe Subject (Observable) - Gerencia a lista de observadores
// Esta classe √© o n√∫cleo do padr√£o Observer. Ela mant√©m uma lista de observadores
// e notifica todos eles quando algo importante acontece. √â como um sistema de
// broadcasting onde o Subject √© a esta√ß√£o de r√°dio e os Observers s√£o os receptores
class Subject {
  constructor() {
    // Array que armazena todos os observadores registrados
    // Cada observador aqui ser√° notificado quando notify() for chamado
    this.observers = [];
  }

  // M√©todo para registrar um novo observador no sistema
  // Verifico se o objeto realmente implementa a interface Observer
  // para evitar erros em tempo de execu√ß√£o
  subscribe(observer) {
    if (observer instanceof Observer) {
      this.observers.push(observer);
      console.log(`üëÄ Observador registrado: ${observer.constructor.name}`);
    } else {
      throw new Error('Observador deve implementar a interface Observer');
    }
  }

  // M√©todo para remover um observador da lista
  // √ötil para cleanup e otimiza√ß√£o de mem√≥ria
  unsubscribe(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
      console.log(`üëã Observador removido: ${observer.constructor.name}`);
    }
  }

  // M√©todo central do padr√£o - notifica todos os observadores
  // Este √© o m√©todo mais importante, pois √© ele que propaga as mudan√ßas
  // por todo o sistema. Cada observador recebe os mesmos dados
  notify(data) {
    console.log(`üîî Notificando ${this.observers.length} observadores com dados:`, data);
    this.observers.forEach(observer => {
      try {
        // Chamo o m√©todo update de cada observador com os dados
        // O try/catch garante que se um observador falhar, os outros continuem funcionando
        observer.update(data);
      } catch (error) {
        console.error(`‚ùå Erro ao notificar observador ${observer.constructor.name}:`, error);
      }
    });
  }
}

// VoteManager - Subject que gerencia vota√ß√£o e notifica observadores
// Esta √© a classe mais importante do sistema. Ela herda de Subject e √© respons√°vel
// por gerenciar todos os votos e notificar os observadores sobre mudan√ßas.
// √â aqui que toda a l√≥gica de vota√ß√£o acontece, incluindo:
// - Processamento de votos individuais e super votos
// - Determina√ß√£o da m√∫sica mais votada
// - Notifica√ß√£o autom√°tica quando h√° mudan√ßas significativas
class VoteManager extends Subject {
  constructor() {
    super();
    // Armazeno a m√∫sica atualmente mais votada para compara√ß√£o
    // Isso me permite detectar quando h√° mudan√ßa de lideran√ßa
    this.currentHighestVoted = null;
  }

  // M√©todo principal para processar votos - cora√ß√£o do sistema de vota√ß√£o
  // Este m√©todo √© chamado sempre que algu√©m vota, seja voto simples ou super voto
  // Ele atualiza a contagem, verifica mudan√ßas e notifica todos os observadores
  processVote(songId, newVoteCount) {
    console.log(`üó≥Ô∏è VoteManager: Processando voto para m√∫sica ${songId} com ${newVoteCount} votos`);
    
    // Encontro a m√∫sica na lista e atualizo seus votos
    // Uso find() porque √© mais eficiente para arrays pequenos
    const song = songs.find(s => s.id === songId);
    if (song) {
      song.votes = newVoteCount;
      console.log(`üó≥Ô∏è Voto registrado para "${song.title}" - Total: ${song.votes} votos`);
      
      // Verifico se houve mudan√ßa na m√∫sica mais votada
      // Esta √© uma parte cr√≠tica pois determina se devo notificar sobre mudan√ßa de lideran√ßa
      const newHighestVoted = this.getHighestVotedSong();
      const hasChanged = !this.currentHighestVoted || 
                        this.currentHighestVoted.id !== newHighestVoted?.id;
      
      if (hasChanged && newHighestVoted) {
        // Nova m√∫sica assumiu a lideran√ßa!
        this.currentHighestVoted = newHighestVoted;
        console.log(`üëë Nova m√∫sica mais votada: "${newHighestVoted.title}" por ${newHighestVoted.artist} (${newHighestVoted.votes} votos)`);
        
        // Notifico todos os observadores sobre a mudan√ßa de lideran√ßa
        // Passo dados completos para que cada observador possa reagir adequadamente
        this.notify({
          type: 'VOTE_CHANGE',
          songId: songId,
          newVotes: newVoteCount,
          highestVoted: newHighestVoted,
          allSongs: this.getAllSongsSorted()
        });
      } else {
        // Apenas atualizo a contagem sem mudan√ßa de lideran√ßa
        // Mesmo assim notifico para manter a UI atualizada
        this.notify({
          type: 'VOTE_UPDATE',
          songId: songId,
          newVotes: newVoteCount,
          highestVoted: this.currentHighestVoted,
          allSongs: this.getAllSongsSorted()
        });
      }
    }
  }

  // M√©todo utilit√°rio para encontrar a m√∫sica mais votada
  // Uso sort() para ordenar por votos e retorno o primeiro elemento
  // Se n√£o houver m√∫sicas, retorno null para evitar erros
  getHighestVotedSong() {
    if (songs.length === 0) return null;
    return [...songs].sort((a, b) => b.votes - a.votes)[0];
  }

  // M√©todo para obter todas as m√∫sicas ordenadas por votos
  // Uso spread operator [...songs] para criar uma nova array e n√£o modificar a original
  // Isso √© importante para evitar efeitos colaterais indesejados
  getAllSongsSorted() {
    return [...songs].sort((a, b) => b.votes - a.votes);
  }

  // M√©todo para adicionar novas m√∫sicas ao sistema
  // Al√©m de adicionar √† lista, notifico todos os observadores
  // para que possam reagir √† nova m√∫sica (ex: atualizar UI)
  addSong(newSong) {
    songs.push(newSong);
    console.log(`üéµ VoteManager: Nova m√∫sica adicionada: "${newSong.title}" por ${newSong.artist}`);
    
    // Notifico observadores sobre a nova m√∫sica
    this.notify({
      type: 'SONG_ADDED',
      song: newSong,
      allSongs: this.getAllSongsSorted()
    });
  }
}

// MusicPlayer - Observador que reage a mudan√ßas de votos
// Esta classe implementa a interface Observer e √© respons√°vel por gerenciar
// a reprodu√ß√£o autom√°tica de m√∫sicas baseada nos votos. √â um exemplo perfeito
// de como o padr√£o Observer desacopla responsabilidades:
// - O VoteManager n√£o precisa saber sobre reprodu√ß√£o de m√∫sica
// - O MusicPlayer n√£o precisa saber sobre l√≥gica de vota√ß√£o
// - Ambos funcionam independentemente mas colaboram atrav√©s do padr√£o Observer
class MusicPlayer extends Observer {
  constructor() {
    super();
    // Estado atual do player de m√∫sica
    this.currentPlaying = null;  // M√∫sica sendo reproduzida atualmente
    this.isPlaying = false;      // Status de reprodu√ß√£o
  }

  // M√©todo update obrigat√≥rio da interface Observer
  // √â chamado automaticamente sempre que o VoteManager notifica mudan√ßas
  // Analiso o tipo de evento e delego para o m√©todo apropriado
  update(data) {
    console.log(`üéµ MusicPlayer: Recebeu atualiza√ß√£o:`, data.type);
    
    // Switch para tratar diferentes tipos de eventos
    // Isso me permite reagir de forma espec√≠fica a cada situa√ß√£o
    switch (data.type) {
      case 'VOTE_CHANGE':
        // Mudan√ßa de lideran√ßa - possivelmente trocar m√∫sica
        this.handleVoteChange(data.highestVoted);
        break;
      case 'VOTE_UPDATE':
        // Atualiza√ß√£o de votos sem mudan√ßa de lideran√ßa
        this.handleVoteUpdate(data);
        break;
      case 'SONG_ADDED':
        // Nova m√∫sica adicionada ao sistema
        this.handleSongAdded(data.song);
        break;
    }
  }

  // Lida com mudan√ßas de lideran√ßa nas vota√ß√µes
  // Se uma nova m√∫sica assumiu a lideran√ßa, automaticamente troco para ela
  // Esta √© a funcionalidade que torna o sistema verdadeiramente reativo
  handleVoteChange(newHighestVoted) {
    if (newHighestVoted && (!this.currentPlaying || this.currentPlaying.id !== newHighestVoted.id)) {
      console.log(`üéµ MusicPlayer: Mudando para nova m√∫sica mais votada: "${newHighestVoted.title}"`);
      this.playTrack(newHighestVoted);
    }
  }

  // Lida com atualiza√ß√µes de votos sem mudan√ßa de lideran√ßa
  // Apenas logo a informa√ß√£o para debug, mas n√£o mudo a m√∫sica atual
  handleVoteUpdate(data) {
    console.log(`üéµ MusicPlayer: Votos atualizados para m√∫sica, l√≠der atual ainda √©: "${data.highestVoted?.title}"`);
  }

  // Lida com adi√ß√£o de novas m√∫sicas
  // Por enquanto apenas logo, mas poderia implementar l√≥gica adicional
  // como adicionar √† playlist ou verificar se deve tocar imediatamente
  handleSongAdded(song) {
    console.log(`üéµ MusicPlayer: Nova m√∫sica dispon√≠vel: "${song.title}" por ${song.artist}`);
  }

  // M√©todo para reproduzir uma m√∫sica espec√≠fica
  // Em uma implementa√ß√£o real, isso controlaria um player de √°udio
  // Por enquanto simulo a reprodu√ß√£o com logs e timeout
  playTrack(song) {
    this.currentPlaying = song;
    this.isPlaying = true;
    console.log(`‚ñ∂Ô∏è MusicPlayer: Tocando agora "${song.title}" por ${song.artist}`);
    console.log(`üîó URL do √°udio: ${song.audioUrl}`);
    
    // Simulo reprodu√ß√£o (em implementa√ß√£o real, controlaria reprodu√ß√£o de √°udio real)
    // O timeout simula o fim da m√∫sica ap√≥s 3 segundos para demo
    setTimeout(() => {
      console.log(`‚è∏Ô∏è MusicPlayer: Terminou de tocar "${song.title}"`);
      this.isPlaying = false;
    }, 3000); // Simulo preview de 3 segundos
  }

  // M√©todo para obter estado atual do player
  // √ötil para APIs que precisam informar sobre o que est√° tocando
  getCurrentPlaying() {
    return {
      song: this.currentPlaying,
      isPlaying: this.isPlaying
    };
  }
}

// UIObserver - Observador que reage a mudan√ßas e atualiza estado da interface
// Esta classe √© respons√°vel por manter o estado da interface usu√°rio sincronizado
// com as mudan√ßas no sistema. √â outro exemplo do poder do padr√£o Observer:
// - A UI se atualiza automaticamente sem polling
// - N√£o preciso acoplar l√≥gica de UI com l√≥gica de neg√≥cio
// - O estado da UI √© sempre consistent com o estado do sistema
class UIObserver extends Observer {
  constructor() {
    super();
    // Estado da interface do usu√°rio
    // Mantenho uma c√≥pia local dos dados para responder rapidamente √†s consultas
    this.uiState = {
      songs: [],           // Lista de m√∫sicas ordenada
      highestVoted: null,  // M√∫sica mais votada atual
      lastUpdate: null     // Timestamp da √∫ltima atualiza√ß√£o
    };
  }

  // M√©todo update obrigat√≥rio da interface Observer
  // Atualizo o timestamp e delego para m√©todos espec√≠ficos baseado no tipo de evento
  update(data) {
    console.log(`üñ•Ô∏è UIObserver: Recebeu atualiza√ß√£o:`, data.type);
    
    // Marco quando foi a √∫ltima atualiza√ß√£o para debugging e cache
    this.uiState.lastUpdate = new Date().toISOString();
    
    // Delego para m√©todos espec√≠ficos baseado no tipo de evento
    switch (data.type) {
      case 'VOTE_CHANGE':
        this.handleVoteChange(data);
        break;
      case 'VOTE_UPDATE':
        this.handleVoteUpdate(data);
        break;
      case 'SONG_ADDED':
        this.handleSongAdded(data);
        break;
    }
  }

  // Lida com mudan√ßas de lideran√ßa nas vota√ß√µes
  handleVoteChange(data) {
    this.uiState.songs = data.allSongs;
    this.uiState.highestVoted = data.highestVoted;
    console.log(`üñ•Ô∏è UIObserver: UI atualizado - nova m√∫sica mais votada: "${data.highestVoted.title}"`);
    console.log(`üìä UIObserver: Placar de votos atualizado`);
  }

  // Lida com atualiza√ß√µes de votos sem mudan√ßa de lideran√ßa
  handleVoteUpdate(data) {
    this.uiState.songs = data.allSongs;
    console.log(`üñ•Ô∏è UIObserver: UI atualizado - votos atualizados para m√∫sica ID: ${data.songId}`);
  }

  // Lida com adi√ß√£o de novas m√∫sicas
  handleSongAdded(data) {
    this.uiState.songs = data.allSongs;
    console.log(`üñ•Ô∏è UIObserver: UI atualizado - nova m√∫sica adicionada: "${data.song.title}"`);
  }

  // M√©todo para obter estado atual da interface
  getUIState() {
    return this.uiState;
  }
}

// ============= INICIALIZA√á√ÉO DO PADR√ÉO OBSERVER =============

// Cria inst√¢ncias
const voteManager = new VoteManager();
const musicPlayer = new MusicPlayer();
const uiObserver = new UIObserver();

// Inscreve observadores no vote manager
voteManager.subscribe(musicPlayer);
voteManager.subscribe(uiObserver);

// ============= EXPRESS APP SETUP =============

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('dist'));

// N√∫mero m√°ximo de m√∫sicas permitidas na vota√ß√£o
const MAX_SONGS = 12;

// Armazenamento de dados em mem√≥ria (substituir por banco de dados em produ√ß√£o)
let songs = [
  {
    id: 'audioslave-cochise',
    title: 'Cochise',
    artist: 'Audioslave',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748878548/Audioslave_-_Cochise_HD_YymwGlbqzIc_lz8zjk.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897363/Audioslave-2002-capa-album-min_iicsnx.webp',
    album: 'Audioslave',
    year: 2002,
    votes: 5,
    addedAt: new Date('2024-01-01').toISOString()
  },
  {
    id: 'deftones-change',
    title: 'Change (In the House of Flies)',
    artist: 'Deftones',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879300/Deftones_-_Change_In_The_House_Of_Flies_oSDNIINcK08_ejs6hn.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897364/Deftones-WhitePony_af94d8a7-be8b-41ea-8f62-8a6410ace2d2_vbfqyq.webp',
    album: 'White Pony',
    year: 2000,
    votes: 8,
    addedAt: new Date('2024-01-02').toISOString()
  },
  {
    id: 'qotsa-bronze',
    title: 'The Bronze',
    artist: 'Queens of the Stone Age',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879302/Queens_Of_The_Stone_Age_The_Bronze_P3kM58n2ceE_x9m9kx.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897363/61bu-cKoykL_nihmew.webp',
    album: 'Queens of the Stone Age',
    year: 1998,
    votes: 3,
    addedAt: new Date('2024-01-03').toISOString()
  },
  {
    id: 'deftones-my-own-summer',
    title: 'My Own Summer (Shove It)',
    artist: 'Deftones',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879303/Deftones_-_My_Own_Summer_vLjOwAPzt4o_xdemns.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897363/3e6814b457a9087e0c46d5a949de2766_ik37wx.webp',
    album: 'Around the Fur',
    year: 1997,
    votes: 6,
    addedAt: new Date('2024-01-04').toISOString()
  },
  {
    id: 'soundgarden-outshined',
    title: 'Outshined',
    artist: 'Soundgarden',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879304/Soundgarden_-_Outshined_Studio_Version_uLZBhlTXHuo_cfqaw1.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897364/71rRNAnVW6L_cpn09c.webp',
    album: 'Badmotorfinger',
    year: 1991,
    votes: 2,
    addedAt: new Date('2024-01-05').toISOString()
  },
  {
    id: 'qotsa-avon',
    title: 'Avon',
    artist: 'Queens of the Stone Age',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748893838/Queens_of_the_Stone_Age_-_Avon_Official_Audio_aimHMr-Ee4o_ay6jsw.mp3',
    albumCover: 'https://upload.wikimedia.org/wikipedia/en/a/a6/Qotsa_lullabies.jpg',
    album: 'Lullabies to Paralyze',
    year: 2005,
    votes: 4,
    addedAt: new Date('2024-01-06').toISOString()
  },
  {
    id: 'qotsa-if-only',
    title: 'If Only',
    artist: 'Queens of the Stone Age',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748893839/Queens_of_the_Stone_Age_-_If_Only_Official_Audio_1HqTh0nd9GE_rojfrl.mp3',
    albumCover: 'https://upload.wikimedia.org/wikipedia/en/a/a6/Qotsa_lullabies.jpg',
    album: 'Lullabies to Paralyze',
    year: 2005,
    votes: 1,
    addedAt: new Date('2024-01-07').toISOString()
  },
  {
    id: 'gorillaz-feel-good-inc',
    title: 'Feel Good Inc.',
    artist: 'Gorillaz',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748893840/Gorillaz_-_Feel_Good_Inc_Lyrics_IbpOfzrNjTY_cwzxnh.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897363/2025-06-02_17-48_adhnkt.png',
    album: 'Demon Days',
    year: 2005,
    votes: 7,
    addedAt: new Date('2024-01-08').toISOString()
  },
  {
    id: 'rhcp-around-the-world',
    title: 'Around The World',
    artist: 'Red Hot Chili Peppers',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748893841/Red_Hot_Chili_Peppers_-_Around_The_World_Official_Music_Video_HD_UPGRADE_a9eNQZbjpJk_d2oido.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897364/304b3f84-9c1f-4620-bd1d-60d6d63ff7fc_fgs0hh.webp',
    album: 'Californication',
    year: 1999,
    votes: 9,
    addedAt: new Date('2024-01-09').toISOString()
  },
  {
    id: 'gorillaz-dare',
    title: 'DARE',
    artist: 'Gorillaz',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748893841/DARE_rIq6i4-8Nww_hfwl3r.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897363/2025-06-02_17-48_adhnkt.png',
    album: 'Demon Days',
    year: 2005,
    votes: 3,
    addedAt: new Date('2024-01-10').toISOString()
  },
  {
    id: 'soundgarden-black-hole-sun',
    title: 'Black Hole Sun',
    artist: 'Soundgarden',
    audioUrl: 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748893842/Soundgarden_-_Black_Hole_Sun_HQ_Y6Kz6aXsBSs_lvcs9q.mp3',
    albumCover: 'https://res.cloudinary.com/dzwfuzxxw/image/upload/v1748897363/soundgarden-superunknown_rvcxuo.webp',
    album: 'Superunknown',
    year: 1994,
    votes: 6,
    addedAt: new Date('2024-01-11').toISOString()
  }
];

let chatMessages = [
  {
    user: 'Sistema',
    message: 'Bem-vindos ao PlayOff! Vote nas suas m√∫sicas favoritas! üéµ',
    timestamp: new Date().toISOString()
  }
];

// Fun√ß√£o utilit√°ria para manter o limite m√°ximo de m√∫sicas no sistema
// Este controle √© importante para evitar que a lista cres√ßa indefinidamente
// e para manter a performance da aplica√ß√£o. Quando o limite √© excedido,
// removo as m√∫sicas mais antigas (por data de adi√ß√£o) mantendo as mais recentes
const maintainSongsLimit = () => {
  if (songs.length > MAX_SONGS) {
    // Ordeno por data de adi√ß√£o (mais antigas primeiro) e removo o excesso
    // Uso toISOString() para garantir compara√ß√£o correta de datas
    songs.sort((a, b) => new Date(a.addedAt) - new Date(b.addedAt));
    const removedSongs = songs.splice(0, songs.length - MAX_SONGS);
    
    console.log(`üßπ Limite de ${MAX_SONGS} m√∫sicas atingido. Removendo ${removedSongs.length} m√∫sica(s) mais antiga(s):`);
    removedSongs.forEach(song => {
      console.log(`   - Removida: "${song.title}" por ${song.artist} (adicionada em ${song.addedAt})`);
    });
  }
};

// Fun√ß√£o auxiliar para obter a m√∫sica mais votada
// Esta fun√ß√£o √© um wrapper conveniente que usa o VoteManager
// Mantenho para compatibilidade com c√≥digo legado
const getHighestVotedSong = () => {
  return voteManager.getHighestVotedSong();
};

// ============= ROTAS DA API REST =============
// Implementei uma API RESTful completa para gerenciar o sistema de vota√ß√£o
// Cada rota tem tratamento de erro adequado e logging detalhado para debugging
// As respostas seguem um padr√£o consistente com status de sucesso/erro

// Rota para buscar todas as m√∫sicas (ordenadas por votos, maior primeiro)
// Esta √© a rota mais importante do sistema pois fornece todos os dados necess√°rios
// para a interface do usu√°rio. Incluo informa√ß√µes do estado atual dos observadores
app.get('/api/songs', (req, res) => {
  try {
    console.log('üì° GET /api/songs - Enviando lista de m√∫sicas ordenada por votos');
    
    // Uso o VoteManager para obter m√∫sicas ordenadas (padr√£o Observer em a√ß√£o)
    const sortedSongs = voteManager.getAllSongsSorted();
    const highestVoted = voteManager.getHighestVotedSong();
    
    // Obtenho estado dos observadores para debugging e monitoring
    const uiState = uiObserver.getUIState();
    const playerState = musicPlayer.getCurrentPlaying();
    
    // Resposta completa com todos os dados necess√°rios para o frontend
    res.json({ 
      songs: sortedSongs,              // Lista ordenada por votos
      highestVoted: highestVoted,      // M√∫sica l√≠der atual
      totalSongs: songs.length,        // Total de m√∫sicas no sistema
      maxSongs: MAX_SONGS,             // Limite m√°ximo permitido
      currentPlaying: playerState,     // Estado do player de m√∫sica
      uiState: uiState,                // Estado da interface
      success: true                    // Flag de sucesso
    });
    
    console.log(`‚úÖ Enviadas ${sortedSongs.length} m√∫sicas. L√≠der: "${highestVoted?.title || 'Nenhuma'}" com ${highestVoted?.votes || 0} votos`);
  } catch (error) {
    console.error('‚ùå Erro ao buscar m√∫sicas:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor ao buscar m√∫sicas', 
      success: false 
    });
  }
});

// Rota para registrar um voto simples em uma m√∫sica
// Esta rota utiliza o padr√£o Observer para notificar automaticamente
// todos os componentes interessados sobre o novo voto
app.post('/api/vote', (req, res) => {
  try {
    const { songId, votes } = req.body;
    
    // Valida√ß√£o de entrada - songId √© obrigat√≥rio
    if (!songId) {
      console.log('‚ùå Tentativa de voto sem songId');
      return res.status(400).json({ 
        error: 'ID da m√∫sica √© obrigat√≥rio para vota√ß√£o', 
        success: false 
      });
    }
    
    // Verifico se a m√∫sica existe no sistema
    const song = songs.find(s => s.id === songId);
    if (!song) {
      console.log(`‚ùå Tentativa de voto em m√∫sica inexistente: ${songId}`);
      return res.status(404).json({ 
        error: 'M√∫sica n√£o encontrada no sistema', 
        success: false 
      });
    }
    
    // Processo o voto usando o VoteManager (padr√£o Observer)
    // Isso automaticamente notificar√° todos os observadores registrados
    const newVoteCount = (song.votes || 0) + 1;
    console.log(`üó≥Ô∏è Processando voto para "${song.title}" - novo total: ${newVoteCount}`);
    voteManager.processVote(songId, newVoteCount);
    
    // Obtenho estados atualizados ap√≥s o voto
    const highestVoted = voteManager.getHighestVotedSong();
    const playerState = musicPlayer.getCurrentPlaying();
    
    // Resposta com informa√ß√µes completas sobre o resultado do voto
    res.json({ 
      song: song,                      // M√∫sica votada
      highestVoted: highestVoted,      // Nova m√∫sica l√≠der (se mudou)
      currentPlaying: playerState,     // Estado atual do player
      message: `Voto registrado para "${song.title}"! Total: ${song.votes} votos`,
      success: true 
    });
    
    console.log(`‚úÖ Voto registrado com sucesso para "${song.title}" por ${song.artist}`);
  } catch (error) {
    console.error('‚ùå Erro ao registrar voto:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor ao processar voto', 
      success: false 
    });
  }
});

// Rota para super voto - adiciona votos suficientes para assumir a lideran√ßa
// O super voto √© uma funcionalidade especial que garante que a m√∫sica escolhida
// ficar√° em primeiro lugar, adicionando votos suficientes para superar a l√≠der atual
app.post('/api/super-vote', (req, res) => {
  try {
    const { songId, totalVotes, votesAdded } = req.body;
    
    // Valida√ß√£o de entrada
    if (!songId) {
      console.log('‚ùå Tentativa de super voto sem songId');
      return res.status(400).json({ 
        error: 'ID da m√∫sica √© obrigat√≥rio para super voto', 
        success: false 
      });
    }
    
    // Verifico se a m√∫sica existe
    const song = songs.find(s => s.id === songId);
    if (!song) {
      console.log(`‚ùå Tentativa de super voto em m√∫sica inexistente: ${songId}`);
      return res.status(404).json({ 
        error: 'M√∫sica n√£o encontrada no sistema', 
        success: false 
      });
    }
    
    console.log(`‚ö° Super voto recebido para "${song.title}" - adicionando ${votesAdded} votos (total: ${totalVotes})`);
    
    // Uso o VoteManager para processar o super voto
    // O padr√£o Observer garantir√° que todos os componentes sejam notificados
    voteManager.processVote(songId, totalVotes);
    
    // Obtenho estados atualizados
    const highestVoted = voteManager.getHighestVotedSong();
    const playerState = musicPlayer.getCurrentPlaying();
    
    // Resposta detalhada sobre o super voto
    res.json({ 
      song: song,
      highestVoted: highestVoted,
      currentPlaying: playerState,
      votesAdded: votesAdded,
      message: `‚ö° Super Voto executado! "${song.title}" agora tem ${song.votes} votos e est√° em 1¬∫ lugar!`,
      success: true 
    });
    
    console.log(`‚úÖ Super voto processado com sucesso! "${song.title}" agora lidera com ${song.votes} votos`);
  } catch (error) {
    console.error('‚ùå Erro ao registrar super voto:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor ao processar super voto', 
      success: false 
    });
  }
});

// Rota para adicionar nova m√∫sica ao sistema
// Esta rota permite que usu√°rios adicionem m√∫sicas atrav√©s da API
// Inclui valida√ß√µes e integra√ß√£o com APIs externas para obter metadados
app.post('/api/songs', async (req, res) => {
  try {
    const { title, artist, audioUrl, albumCover, album, year } = req.body;
    
    // Valida√ß√µes obrigat√≥rias
    if (!title || !artist) {
      console.log('‚ùå Tentativa de adicionar m√∫sica sem dados obrigat√≥rios');
      return res.status(400).json({ 
        error: 'T√≠tulo e artista s√£o obrigat√≥rios', 
        success: false 
      });
    }
    
    // Verifico se a m√∫sica j√° existe para evitar duplicatas
    const existingSong = songs.find(s => 
      s.title.toLowerCase() === title.toLowerCase() && 
      s.artist.toLowerCase() === artist.toLowerCase()
    );
    
    if (existingSong) {
      console.log(`‚ùå M√∫sica j√° existe: "${title}" por ${artist}`);
      return res.status(409).json({ 
        error: `"${title}" por ${artist} j√° est√° na lista de vota√ß√£o`, 
        success: false 
      });
    }
    
    // Verifico o limite de m√∫sicas antes de adicionar
    if (songs.length >= MAX_SONGS) {
      console.log(`‚ùå Limite de ${MAX_SONGS} m√∫sicas atingido`);
      return res.status(400).json({ 
        error: `Limite m√°ximo de ${MAX_SONGS} m√∫sicas atingido`, 
        success: false 
      });
    }
    
    console.log(`üéµ Adicionando nova m√∫sica: "${title}" por ${artist}`);
    
    // Busco capa do √°lbum se n√£o foi fornecida
    let finalAlbumCover = albumCover;
    if (!finalAlbumCover) {
      console.log(`üé® Buscando capa do √°lbum para: ${artist} - ${title}`);
      finalAlbumCover = await searchAlbumCover(artist, album, title);
      
      // Se n√£o encontrar, uso placeholder
      if (!finalAlbumCover) {
        finalAlbumCover = generatePlaceholderCover(artist, title);
        console.log(`üé® Usando capa placeholder para "${title}"`);
      }
    }
    
    // Crio nova m√∫sica com dados completos
    const newSong = {
      id: `song-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, // ID √∫nico
      title: title.trim(),
      artist: artist.trim(),
      album: album || '√Ålbum Desconhecido',
      audioUrl: audioUrl || 'https://res.cloudinary.com/dzwfuzxxw/video/upload/v1748879303/sample_audio_preview.mp3',
      albumCover: finalAlbumCover,
      year: year || new Date().getFullYear(),
      votes: 0,                                    // Come√ßa com zero votos
      addedAt: new Date().toISOString(),          // Timestamp de adi√ß√£o
      addedBy: 'API'                              // Fonte da adi√ß√£o
    };
    
    // Uso o VoteManager para adicionar (padr√£o Observer)
    voteManager.addSong(newSong);
    
    // Mantenho o limite de m√∫sicas
    maintainSongsLimit();
    
    console.log(`‚úÖ M√∫sica adicionada com sucesso: "${newSong.title}" (ID: ${newSong.id})`);
    
    res.status(201).json({ 
      song: newSong,
      message: `"${newSong.title}" por ${newSong.artist} foi adicionada com sucesso!`,
      totalSongs: songs.length,
      success: true 
    });
    
  } catch (error) {
    console.error('‚ùå Erro ao adicionar m√∫sica:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor ao adicionar m√∫sica', 
      success: false 
    });
  }
});

// Rota para health check - verifica se o servidor est√° funcionando
// √ötil para monitoring e debugging da aplica√ß√£o
app.get('/api/health', (req, res) => {
  console.log('üîç Health check requisitado');
  
  // Informa√ß√µes detalhadas sobre o estado do sistema
  const healthInfo = {
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    totalSongs: songs.length,
    maxSongs: MAX_SONGS,
    observersRegistered: voteManager.observers.length,
    highestVoted: voteManager.getHighestVotedSong(),
    playerStatus: musicPlayer.getCurrentPlaying(),
    uiState: uiObserver.getUIState(),
    memoryUsage: process.memoryUsage(),
    version: '3.1.0'
  };
  
  res.json(healthInfo);
  console.log('‚úÖ Health check respondido - Sistema funcionando normalmente');
});

// Inicializa√ß√£o do servidor e configura√ß√£o final
// Esta se√ß√£o √© respons√°vel por inicializar todo o sistema e configurar
// o estado inicial da aplica√ß√£o. √â aqui que toda a arquitetura se junta
const server = app.listen(PORT, () => {
  console.log(`üìÄ Carregadas ${songs.length} m√∫sicas com URLs do Cloudinary`);
  console.log(`üéµ PlayOff Music Voting App - Sistema de Vota√ß√£o Musical`);
  console.log(`üì± Frontend: http://localhost:${PORT}/`);
  console.log(`üéß Backend com Padr√£o Observer ativo!`);
  console.log(`üëÄ Observadores registrados: ${voteManager.observers.length}`);
  console.log(`   - ${musicPlayer.constructor.name}: Gerencia reprodu√ß√£o de m√∫sica`);
  console.log(`   - ${uiObserver.constructor.name}: Gerencia atualiza√ß√µes de estado da UI`);
  console.log(`üó≥Ô∏è Vote Manager: Pronto para receber votos`);
  console.log(`üéµ Music Player: Pronto para reproduzir m√∫sicas`);
  console.log(`üí¨ Sistema de Chat: Pronto para conversas`);
  
  // Inicializo o VoteManager com a m√∫sica mais votada atual
  // Isso garante que o sistema comece com o estado correto
  // e que o player j√° saiba qual m√∫sica deveria estar tocando
  const initialHighestVoted = voteManager.getHighestVotedSong();
  if (initialHighestVoted) {
    voteManager.currentHighestVoted = initialHighestVoted;
    console.log(`üëë M√∫sica inicial mais votada: "${initialHighestVoted.title}" por ${initialHighestVoted.artist} (${initialHighestVoted.votes} votos)`);
    
    // Aciono a configura√ß√£o inicial do player de m√∫sica
    // Isso faz com que a m√∫sica mais votada comece a "tocar" automaticamente
    musicPlayer.playTrack(initialHighestVoted);
  }
  
  console.log(`üöÄ Sistema pronto para funcionar! Que comecem as vota√ß√µes!`);
});

// Gerenciamento de desligamento gracioso do servidor
// Implemento um shutdown gracioso para garantir que todas as opera√ß√µes
// sejam finalizadas adequadamente antes de encerrar o processo
// Isso √© especialmente importante em produ√ß√£o para evitar perda de dados
process.on('SIGTERM', () => {
  console.log('üõë Servidor sendo desligado graciosamente...');
  server.close(() => {
    console.log('‚úÖ Servidor fechado com sucesso');
    console.log('üëã At√© mais! Obrigado por usar o PlayOff!');
  });
});