// ColorThief v2.3.0 - Minimal version for color extraction
class ColorThief {
    getColor(img, quality = 10) {
        const palette = this.getPalette(img, 5, quality);
        return palette[0];
    }

    getPalette(img, colorCount = 10, quality = 10) {
        if (typeof img === 'string') {
            const imgElement = new Image();
            imgElement.src = img;
            img = imgElement;
        }

        if (!img.complete || !img.naturalWidth) {
            return [[0, 0, 0]];
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width = img.naturalWidth;
        const height = canvas.height = img.naturalHeight;

        ctx.drawImage(img, 0, 0);

        let imageData;
        try {
            imageData = ctx.getImageData(0, 0, width, height);
        } catch (e) {
            return [[0, 0, 0]];
        }

        const pixelArray = this.createPixelArray(imageData.data, quality);
        const cmap = this.quantize(pixelArray, colorCount);
        
        if (!cmap) {
            return [[0, 0, 0]];
        }

        const palette = cmap.palette();
        return palette;
    }

    createPixelArray(imgData, quality) {
        const pixels = imgData;
        const pixelCount = imgData.length / 4;
        const pixelArray = [];

        for (let i = 0; i < pixelCount; i += quality) {
            const offset = i * 4;
            const r = pixels[offset + 0];
            const g = pixels[offset + 1];
            const b = pixels[offset + 2];
            const a = pixels[offset + 3];

            // Skip transparent pixels
            if (a >= 125) {
                if (!(r > 250 && g > 250 && b > 250)) {
                    pixelArray.push([r, g, b]);
                }
            }
        }
        return pixelArray;
    }

    quantize(pixels, maxColors) {
        if (!pixels.length || maxColors < 2 || maxColors > 256) {
            return null;
        }

        const vbox = this.vboxFromPixels(pixels);
        const pq = new PriorityQueue((a, b) => a.count() - b.count());
        
        pq.push(vbox);

        // First split
        this.iterSplit(pq, Math.ceil(maxColors / 2));
        
        // Second split
        const pq2 = new PriorityQueue((a, b) => a.count() * a.volume() - b.count() * b.volume());
        while (pq.size()) {
            pq2.push(pq.pop());
        }
        
        this.iterSplit(pq2, maxColors - pq2.size());

        const cmap = new CMap();
        while (pq2.size()) {
            cmap.push(pq2.pop());
        }

        return cmap;
    }

    vboxFromPixels(pixels) {
        let rmin = 1000000, rmax = 0;
        let gmin = 1000000, gmax = 0;
        let bmin = 1000000, bmax = 0;

        pixels.forEach(pixel => {
            const [r, g, b] = pixel;
            if (r < rmin) rmin = r;
            if (r > rmax) rmax = r;
            if (g < gmin) gmin = g;
            if (g > gmax) gmax = g;
            if (b < bmin) bmin = b;
            if (b > bmax) bmax = b;
        });

        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, pixels);
    }

    iterSplit(pq, target) {
        let ncolors = 1;
        while (ncolors < target) {
            const vbox = pq.pop();
            if (!vbox) break;

            const [vbox1, vbox2] = this.splitBox(vbox);
            pq.push(vbox1);
            if (vbox2) {
                pq.push(vbox2);
                ncolors++;
            }
        }
    }

    splitBox(vbox) {
        if (vbox.count() === 0) return [vbox, null];

        const rw = vbox.r2 - vbox.r1 + 1;
        const gw = vbox.g2 - vbox.g1 + 1;
        const bw = vbox.b2 - vbox.b1 + 1;
        const maxw = Math.max(rw, gw, bw);

        let total = 0;
        const partialsum = [];
        const lookaheadsum = [];
        let i, j, k, sum, index;

        if (maxw === rw) {
            for (i = vbox.r1; i <= vbox.r2; i++) {
                sum = 0;
                for (j = vbox.g1; j <= vbox.g2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = (i << (2 * 5)) + (j << 5) + k;
                        sum += (vbox.histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        } else if (maxw === gw) {
            for (i = vbox.g1; i <= vbox.g2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.b1; k <= vbox.b2; k++) {
                        index = (j << (2 * 5)) + (i << 5) + k;
                        sum += (vbox.histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        } else {
            for (i = vbox.b1; i <= vbox.b2; i++) {
                sum = 0;
                for (j = vbox.r1; j <= vbox.r2; j++) {
                    for (k = vbox.g1; k <= vbox.g2; k++) {
                        index = (j << (2 * 5)) + (k << 5) + i;
                        sum += (vbox.histo[index] || 0);
                    }
                }
                total += sum;
                partialsum[i] = total;
            }
        }

        const left = maxw === rw ? vbox.r1 : maxw === gw ? vbox.g1 : vbox.b1;
        const right = maxw === rw ? vbox.r2 : maxw === gw ? vbox.g2 : vbox.b2;

        for (i = left; i <= right; i++) {
            if (partialsum[i] > total / 2) {
                const vbox1 = vbox.copy();
                const vbox2 = vbox.copy();
                const cut = i - left;
                const dim = maxw === rw ? 'r' : maxw === gw ? 'g' : 'b';
                
                vbox1[dim + '2'] = i;
                vbox2[dim + '1'] = i + 1;
                
                return [vbox1, vbox2];
            }
        }

        return [vbox, null];
    }
}

class VBox {
    constructor(r1, r2, g1, g2, b1, b2, pixels) {
        this.r1 = r1;
        this.r2 = r2;
        this.g1 = g1;
        this.g2 = g2;
        this.b1 = b1;
        this.b2 = b2;
        this.pixels = pixels;
        this.histo = this.buildHistogram();
    }

    buildHistogram() {
        const histo = {};
        this.pixels.forEach(pixel => {
            const [r, g, b] = pixel;
            const index = (r << (2 * 5)) + (g << 5) + b;
            histo[index] = (histo[index] || 0) + 1;
        });
        return histo;
    }

    volume() {
        return (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);
    }

    count() {
        return this.pixels.length;
    }

    copy() {
        return new VBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.pixels);
    }

    avg() {
        let mult = 1 << (8 - 5);
        let rsum = 0, gsum = 0, bsum = 0, hval, i;
        
        for (i in this.histo) {
            hval = this.histo[i];
            rsum += (((i >> (2 * 5)) & ((1 << 5) - 1)) + 0.5) * mult * hval;
            gsum += (((i >> 5) & ((1 << 5) - 1)) + 0.5) * mult * hval;
            bsum += ((i & ((1 << 5) - 1)) + 0.5) * mult * hval;
        }

        const total = this.count();
        return total ? [~~(rsum / total), ~~(gsum / total), ~~(bsum / total)] : [0, 0, 0];
    }
}

class PriorityQueue {
    constructor(compareFn) {
        this.compare = compareFn;
        this.data = [];
    }

    push(item) {
        this.data.push(item);
    }

    pop() {
        if (this.data.length === 0) return null;
        this.data.sort(this.compare);
        return this.data.shift();
    }

    size() {
        return this.data.length;
    }
}

class CMap {
    constructor() {
        this.vboxes = [];
    }

    push(vbox) {
        this.vboxes.push(vbox);
    }

    palette() {
        return this.vboxes.map(vbox => vbox.avg());
    }
}

window.ColorThief = ColorThief; 